# Отчет по домашней работе № 3
Выполнила: Мягкова Анна

Предварительные замеры времени работы
Для замеров времени работы будем использовать тест который прилагался к коду размером $36 \times 84$:
```
char field[N][M + 1] = {
    "####################################################################################",
    "#                                                                                  #",
    "#                                                                                  #",
    "#                                                                                  #",
    "#                                                                                  #",
    "#                                                                                  #",
    "#                                       .........                                  #",
    "#..............#            #           .........                                  #",
    "#..............#            #           .........                                  #",
    "#..............#            #           .........                                  #",
    "#..............#            #                                                      #",
    "#..............#            #                                                      #",
    "#..............#            #                                                      #",
    "#..............#            #                                                      #",
    "#..............#............#                                                      #",
    "#..............#............#                                                      #",
    "#..............#............#                                                      #",
    "#..............#............#                                                      #",
    "#..............#............#                                                      #",
    "#..............#............#                                                      #",
    "#..............#............#                                                      #",
    "#..............#............#                                                      #",
    "#..............#............################                     #                 #",
    "#...........................#....................................#                 #",
    "#...........................#....................................#                 #",
    "#...........................#....................................#                 #",
    "##################################################################                 #",
    "#                                                                                  #",
    "#                                                                                  #",
    "#                                                                                  #",
    "#                                                                                  #",
    "#                                                                                  #",
    "#                                                                                  #",
    "#                                                                                  #",
    "#                                                                                  #",
    "####################################################################################",
};
```

Выполним предварительный замер и запишем в таблицу, во время замеров не выводим симуляцию на экран.
Время работы симуляции в микросекундах в зависимости от количества кадров симуляции
| № замера  | 10 кадров в симуляции | 50 кадров в симуляции | 100 кадров в симуляции | 500 кадров в симуляции |
| :---:  | :---:       |     :---:      |          :---: | :---: |
| 1 | 1142644   | 6287829     | 10678431    | 243737543 | 
| 2 | 1119652 | 5417384 | 10752786 | 228202879 | 
| 3 | 1162354 | 5319526 | 10708937 | 231892949 | 
| Average | 1141550   | 5674913     | 10713384    | 234611123 | 

Теперь создадим структуру ThreadPool, которую можно инициализировать количеством создаваемых потоков. Далее с помощью шаблонного метода void put(const Func func, Type_arguments ... args); можно передовать тредпулу функцию для исполнения в каком то потоке и ее аргументы. Чтобы дождаться исполнения всех текущих задач нужно вызвать метод void wait(). Добваим как член класса Simulation TreadPool. Теперь у симуляции есть возможность запускать какие то ее части в нескольких патоках. 
#### Некоторые улучшения
- Распаралелим тогда обход матрицы при копировании двумерного массива p в массив old_p. В данном случае каждая строчка будет копироваться каким нибудь потоком, что увеличит скорость этой операции.
```
void copy_str(Fixed * fir, Fixed * sec,  size_t& cnt) {
    for (int j = 0; j < cnt; j++) {
        fir[j] = sec[j];
    }
}
///////////////////в функции start()///////////////////////////
for (int i = 0; i < N; i++) {
    thread_pool->put(copy_str, ref(old_p[i]), ref(p[i]), ref(M));
}
thread_pool -> wait();
```
- Распаралелим также функцию void clear(); в структуре VectorField. В функции start() нужно отчищать velocity_flow. Для этого передадим в функцию инициализации VectorField еще указатель на тредпул и также распаралелилим обход матрицы как и в прошлый раз:
```
void clear_func(array<Fixed, 4> * v, size_t& cnt) {
    for (int j = 0; j < cnt; j++) {
        v[j] = {};
    }
}
////////////////////в структуре VectorField//////////////////////////
void clear() {
    for (int i = 0; i < N; i++) {
        thread_pool->put(clear_func, ref(v[i]), ref(M));
    }
    thread_pool -> wait();
}
```
- Также сделаем ускорение не за счет паралелизма, немного исправим сам код:
-- Структура ParticleParams Встречается во всем коде 2 раза и нужна она только для того чтобы свапнуть 3 пары элементов. Можно предположить что каждый раз объявлять целую структуру чтобы просто поменять местами 3 числа накладно -> избавимся от нее. В место нее добавим код в функции start():
```
swap(field[x][y], field[nx][ny]);
swap(p[x][y], p[nx][ny]);
swap(velocity.v[x][y], velocity.v[nx][ny]);
```
-- Также функция Fixed &get(int x, int y, int dx, int dy); исползует функцию ranges::find(deltas, pair(dx, dy)) что на самом деле достаточно расочительно, ведь в массиве deltas всего 4 элемента и гораздо проще просто сделать два if и получить тоже самое. Я написала вместо нее тернарное выражение:
```
size_t i = (dx == 0? (dy < 0 ? 2 : 3) : (dx < 0? 0: 1));
```
Теперь произведем еще один замер времени выполнения, во время замеров не выводим симуляцию на экран.
Время работы симуляции в микросекундах в зависимости от количества кадров симуляции, количество потоков 1 (Для проверки улучшений не связанных с паралелизмом)
| № замера  | 10 кадров в симуляции | 50 кадров в симуляции | 100 кадров в симуляции | 500 кадров в симуляции |
| :---:  | :---:       |     :---:      |          :---: | :---: |
| 1 | 649919   | 2073778     | 3577123    | 74111250 | 
| 2 | 541094 | 6053060 | 3377596 | 75652585 | 
| 3 | 316336 | 3466644 | 3196430 | 76448774 | 
| Average | 502449   | 3864494     | 3383716    | 75404203 | 

На самом большом тесте ускорение примерно в 234611123 / 75404203 = 3 раза

Теперь произведем еще один замер времени выполнения, во время замеров не выводим симуляцию на экран.
Время работы симуляции в микросекундах в зависимости от количества кадров симуляции, количество потоков 8 (Для проверки улучшений с паралелизмом)
| № замера  | 10 кадров в симуляции | 50 кадров в симуляции | 100 кадров в симуляции | 500 кадров в симуляции |
| :---:  | :---:       |     :---:      |          :---: | :---: |
| 1 | 133836   | 2739035     | 2878029    | 23602013 | 
| 2 | 907874 | 2714055 | 1561082 | 14302020 | 
| 3 | 702399 | 3516846 | 2054649 | 33043857 | 
| Average | 581369   | 2989978     | 2164586    | 23649296 | 

Относительно начального состояния ускорение примерно в 234611123 / 23649296 = 9 раз, относительно ускоренного варианта ускорение примерно в 75404203 / 23649296 = 3 раза

#### Сделаем небольшое заключение:
- Есть возможность выбирать количество потоков
- Программа корректно работает в несколько потоков
- Есть ускорение без паралелизма
- Есть ускорение за счет паралелизма
- Есть отчет)

Запускать:
g++ -std=c++20  main.cpp fixed_and_thread_pool.h -o main.exe
./main.exe
